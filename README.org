* Om Next plus Datomic Tutorial

This tutorial will simulate a data flow between om-next and datomic.
A user will enter a car make, like BMW or Toyota, and a list of models
will be sent from the backend to the front end.

** Om Next Data Model

On the front end we'll model this with the following map structure:

#+BEGIN_SRC clojure
  {:current/car
   {:car/make "Toyota"
    :make/models [{:model "Tacoma"}
                  {:model "Tercel"}]}}
#+END_SRC

** Datomic Modeling

To support this on the datomic side we'll have data stored like:

#+BEGIN_SRC clojure
  [{:car/make "Toyota"
    :make/models [{:model "Tacoma"}
                  {:model "Tercel"}]}
   {:car/make "BMW"
    :make/models [{:model "325xi"}
                  {:model "x5"}]}]
#+END_SRC

Our pull pattern in our query will look like:

#+BEGIN_SRC clojure
[{:make/models [:model]}]
#+END_SRC

** Om Next UI

The queries of our Om Next components are:

#+BEGIN_SRC clojure
(defui CarModel
  (query [this] [:model])
(defui CarRoot
  (query [this] [:current/car {:make/models (om/get-query CarModel)}])
#+END_SRC

** Compare Queries

Om Next Query

#+BEGIN_SRC clojure
[:current/car {:make/models [:model]}]
#+END_SRC

Datomic Pull Pattern

#+BEGIN_SRC clojure
[{:make/models [:model]}]
#+END_SRC

* Datomic Again

So our query on the datomic takes in a make as a variable and returns
the associated models.

We could say the input would be two values.  The first is the where
clause.  Get the entity who's ~:car/make~ attribute has the value
~Toyota~.  We can express this with a datomic where clause that looks
like:

#+BEGIN_SRC clojure
  [?e :car/make "Toyota"]
#+END_SRC

In this case, the found entity is stored in the variable ~?e~.  

Next we have to say, with this found entity, what data of it do we
want back?  Remember the shape of the data in Datomic looks like:

#+BEGIN_SRC clojure
  [{:car/make "Toyota"
    :make/models [{:model "Tacoma"}
                  {:model "Tercel"}]}
   {:car/make "BMW"
    :make/models [{:model "325xi"}
                  {:model "x5"}]}]
#+END_SRC

So we can say, well, we want the associate model names.  A pull
pattern that looks like this:

#+BEGIN_SRC clojure
  [{:make/models [:model]}]
#+END_SRC

or more completely:

#+BEGIN_SRC clojure
  '[(pull ?e [{:make/models [:model]}]) ...]
#+END_SRC

which basically reads: from the found entity ~?e~ find the reference
attribute ~:make/models~.  Follow that reference, and from the found
children entities, get the values for the ~:model~ attribute.

When we run this in datomic we predictably get the pull pattern
/filled/ out:

#+BEGIN_SRC clojure
#:make{:models [{:model "Tacoma"} {:model "Tercel"}]}
#+END_SRC


** Om Next Reader Return Value

If I query for a key, then the returned value from the reader function
should be a map with a key 
